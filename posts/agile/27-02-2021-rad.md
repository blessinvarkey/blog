## Implementing the Rapid Application Developement model

Working with TCS's Rapid Labs over the last 7+ months has given quite an exposure to implementing use cases which uses the Rapid Application Model (on which Rapid is based). Though it was pitched by James Martin as a response to the Waterfall model, RAD implementation may not be ideal for every use case/ project scenario. To understand it further, lets first have a look at the two most popular definitions of Rapid Application Development: 

- Rapid Application Development model is a software development process based on prototyping without any specific planning.

- Rapid Application Development is a software development methodology that uses minimum planning in the favor of rapid prototyping. 

Rapid Application Development focuses on gathering requirements through workshops or focus groups, early testing of the prototypes by the customer using _iterative and incremental delivery, _reuse of the existing prototypes_(components), _continous integration_ and _rapid delivery_. 

The RAD model contains small teams comprising of (multi-talented, highly skilled)developers, domain experts, customer reps and other IT resources. 

The prototypes should be reusable. 

## So, what is a prototype? 
A prototype is a working model that is functionally equivalent to a component of the product. 

The functional modules are developed as parallel as prototypes and are integrated to make the complete product for faster product delivery. 

With no detailed planning, it makes it easier to incorporate the changes within the development process. 

## The RAD process

- __THINK:__ Requirements Gathering/Business Modelling & Analysis
- __MAKE:__ Prototype/ 
- __EVALUATE:__: Rapid construction & feedback gathering; and
- Finalize product / implementation.

![](https://codebots.com/generated/_blog/app-development/what-is-rapid-application-development-rad/DT-276_-1-4000-361e91d30.webp)

## Waterfall vs The RAD Model 

![](https://codebots.com/generated/_blog/app-development/what-is-rapid-application-development-rad/RAD-Blog_Infographic-2500-6b16cc069.webp)

Model proposed by James Martin

![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/RADModel.JPG/640px-RADModel.JPG)

The James Martin approach to RAD divides the process into four distinct phases:

- __Requirements planning phase__ – combines elements of the system planning and systems analysis phases of the systems development life cycle (SDLC). Users, managers, and IT staff members discuss and agree on business needs, project scope, constraints, and system requirements. It ends when the team agrees on the key issues and obtains management authorization to continue.
- __User design phase__ – during this phase, users interact with systems analysts and develop models and prototypes that represent all system processes, inputs, and outputs. The RAD groups or subgroups typically use a combination of joint application design (JAD) techniques and CASE tools to translate user needs into working models. User design is a continuous interactive process that allows users to understand, modify, and eventually approve a working model of the system that meets their needs.
- __Construction phase__ – focuses on program and application development task similar to the SDLC. In RAD, however, users continue to participate and can still suggest changes or improvements as actual screens or reports are developed. Its tasks are programming and application development, coding, unit-integration and system testing.
- __Cutover phase__ – resembles the final tasks in the SDLC implementation phase, including data conversion, testing, changeover to the new system, and user training. Compared with traditional methods, the entire process is compressed. As a result, the new system is built, delivered, and placed in operation much sooner.[7]

## RAD & Prototypes
The first such RAD alternative was developed by Barry Boehm and was known as the spiral model. Boehm and other subsequent RAD approaches emphasized developing prototypes as well as or instead of rigorous design specifications. Prototypes had several advantages over traditional specifications:

Risk reduction. A prototype could test some of the most difficult potential parts of the system early on in the life-cycle. This can provide valuable information as to the feasibility of a design and can prevent the team from pursuing solutions that turn out to be too complex or time-consuming to implement. This benefit of finding problems earlier in the life-cycle rather than later was a key benefit of the RAD approach. The earlier a problem can be found the cheaper it is to address.
Users are better at using and reacting than at creating specifications. In the waterfall model it was common for a user to sign off on a set of requirements but then when presented with an implemented system to suddenly realize that a given design lacked some critical features or was too complex. In general most users give much more useful feedback when they can experience a prototype of the running system rather than abstractly define what that system should be.
Prototypes can be usable and can evolve into the completed product. One approach used in some RAD methods was to build the system as a series of prototypes that evolve from minimal functionality to moderately useful to the final completed system. The advantage of this besides the two advantages above was that the users could get useful business functionality much earlier in the process. [[2](https://web.archive.org/web/20180329032706/http://www.dimap.ufrn.br/~jair/ES/artigos/SpiralModelBoehm.pdf)]

When does it work best? 

1. Flexible and adaptable to changes
2. It is useful when you have to reduce the overall project risk
3. It is adaptable and flexible to changes
4. It is easier to transfer deliverables as scripts, high-level abstractions and intermediate codes are used
5. Due to code generators and code reuse, there is a reduction of manual coding
6. Due to prototyping in nature, there is a possibility of lesser defects
7. Each phase in RAD delivers highest priority functionality to client
8. With less people, productivity can be increased in short time
9. It requires developers and customers who are heavily commited
10. Changing requirements can be accomodated
11. Progress can be measured
12. Iteration time can be short with powerful RAD tools.
13. Productivity with fewer people in a short time. 
14. Reduced developement time
15. Increases reusability of components
16. Quick initial reviews occur
17. Encourages customer feedback
18. Integration from very begining solves a lot of integration issues. 
19. Suitable for systems that are component based and scalable. 




## Challenges 
1. Inapplicable to cheaper projects as the cost of modelling and automation is very high. 
2. When technical risk is too high, it is not __suitable__
3. Dependency on small highly skilled team. 
4. High dependency on modelling skills
5. Management complexity
6. Requires user involvement throughout the life cycle.

